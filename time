
#if OS == .WINDOWS {
    #import "Windows";
} else {
    #import "POSIX";
}

#import "Math";
#import "Random";
#import "Basic";

#run {

    context.print_style.default_format_struct.use_newlines_if_long_form = true;

    leap_years_before :: (year: s64) -> s64 {
        floor_div :: (dividend: int, $ divisor: int) -> int {
            offset := cast(int) (dividend <= 0 && dividend % divisor);
            return dividend / divisor - offset;
        }

        result := floor_div(year, 4) - floor_div(year, 100) + floor_div(year, 400);
        return result;
    }

    formosa_calendar_to_apollo :: (ct: Calendar_Time) -> Apollo_Time {
        leap_year_count := leap_years_before(cast(s64) ct.year - 1) - leap_years_before(1970);
        year_difference := cast(s64) ct.year - 1970;

        seconds := 31536000 * (year_difference - leap_year_count);
        seconds += 31622400 * leap_year_count;

        for 0..ct.month_starting_at_0 - 1 {
            days :: int.[
                31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,
            ];

            if it == days.count break;
            seconds += 86400 * days[it];
        }

        is_leap_year := (ct.year % 4 == 0) && (!(ct.year % 100 == 0) || (ct.year % 400 == 0));
        if ct.month_starting_at_0 > 1 && is_leap_year {
            seconds += 86400;
        }

        seconds += 86400 * cast(int) ct.day_of_month_starting_at_0;
        seconds += cast(int) ct.hour * 60 * 60 + cast(int) ct.minute * 60 + cast(int) ct.second;

        APOLLO_TIME_FOR_JAN_1_1970 :: Apollo_Time.{low=0xdbd87f0edb7c8000, high=0x300};

        apollo := seconds_to_apollo(seconds);
        apollo += milliseconds_to_apollo(ct.millisecond);
        apollo += APOLLO_TIME_FOR_JAN_1_1970;
        return apollo;
    }

    // Now                       1970    Moon landing                              0 AD
    // |-------------------------|-------|-----------------------------------------|

    formosa_apollo_to_calendar :: (apollo: Apollo_Time) -> Calendar_Time {
        APOLLO_TIME_FOR_JAN_1_1970 :: Apollo_Time.{low=0xdbd87f0edb7c8000, high=0x300};
        milliseconds := to_milliseconds(apollo - APOLLO_TIME_FOR_JAN_1_1970);

        seconds      := milliseconds / 1000;
        minutes      := seconds      / 60;
        hours        := minutes      / 60;
        total_days   := hours        / 24;

        milliseconds -= seconds      * 1000;
        seconds      -= minutes      * 60;
        minutes      -= hours        * 60;
        hours        -= total_days   * 24;

        // Years is a number of years with roughly the correct number of leap years behind it.
        years := total_days / 365;
        leap_year_count := leap_years_before(years + 2);
        // We now know the number of leap years.

        // This year count is how many non-leap years there are.
        years = (total_days - leap_year_count * 366) / 365;
        years += leap_year_count;

        days := total_days - (years - leap_year_count) * 365;
        days -= leap_year_count * 366;

        // print("% - %\n", leap_year_count, leap_years_before(years - 1));

        years += 1970;
        is_leap_year := (years % 4 == 0) && (!(years % 100 == 0) || (years % 400 == 0));
        if is_leap_year && days < 59 days += 1;

        ct: Calendar_Time;

        days_in_month := int.[
            31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,
        ];

        // print("%\n", leap_year_count);

        month: int;
        for days_in_month {
            month += 1;

            if days >= it {
                days -= it;
            } else {
                month = xx it_index;
                break;
            }
        }

        ct.year = xx years;
        // is_leap_year := (ct.year % 4 == 0) && (!(ct.year % 100 == 0) || (ct.year % 400 == 0));
        // if is_leap_year && month < 2 month_day += 1;

        ct.day_of_week_starting_at_0 = xx ((4 + total_days) % 7);

        ct.month_starting_at_0 = xx month;
        ct.day_of_month_starting_at_0 = xx days;

        ct.hour = xx hours;
        ct.minute = xx minutes;
        ct.second = xx seconds;
        ct.millisecond = xx milliseconds;
        return ct;
    }

    failures: int;
    attempts: int;
    for 1..20000 {
        apollo := current_time_consensus();
        // apollo.low = xx random_get();
        apollo.high += xx random_get() % 45000;

        calendar_linux := to_calendar(apollo);
        calendar_formosa := formosa_apollo_to_calendar(apollo);

        attempts += 1;
        if calendar_linux != calendar_formosa {
            failures += 1;
            print("\nMismatch!!!\n=======================\nIndex: %\nLinux: %\nFormosa: %\n", it, calendar_linux, calendar_formosa);
        }
    }
    print("Successes: %/%\n", (attempts - failures), attempts);

//    for -1_000..1_000 {
//        // cal := to_calendar(current_time_consensus());
//        cal: Calendar_Time;
//        cal.year = 1666; // xx (random_get() % 300 + 2000);
//        cal.month_starting_at_0 = xx (random_get() % 12);
//        
//        days :: int.[
//            31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,
//        ];
//        cal.day_of_month_starting_at_0 = xx (random_get() % xx days[cal.month_starting_at_0]);
//        // cal.day_of_week_starting_at_0 = xx (random_get() % 7);
//        
//        cal.hour = xx (random_get() % 24);
//        cal.minute = xx (random_get() % 59);
//        cal.second = xx (random_get() % 59);
//        cal.millisecond = xx (random_get() % 1000);
//        
//        apollo_linux := calendar_to_apollo(cal);
//        apollo_formosa := formosa_calendar_to_apollo(cal);
//        if apollo_linux != apollo_formosa {
//            print("=======================\nMismatch!!!\nIndex:%\nLinux: %\nFormosa: %\nCalendar: %\n\n", it, apollo_linux, apollo_formosa, cal);
//        }
//    }

    operator == :: (a: Calendar_Time, b: Calendar_Time) -> bool {
        result := true;
        result &&= a.year == b.year;
        result &&= a.hour == b.hour;
        result &&= a.minute == b.minute;
        result &&= a.second == b.second;
        result &&= a.millisecond - b.millisecond < 2;

        result &&= a.month_starting_at_0 == b.month_starting_at_0;
        result &&= a.day_of_month_starting_at_0 == b.day_of_month_starting_at_0;
        result &&= a.day_of_week_starting_at_0 == b.day_of_week_starting_at_0;
        return result;
    }
    print("Done.\n");
//    get_apollo_moon_landing_time_on_january_1_0000_for_unix();
    return;
}

get_apollo_moon_landing_time_on_january_1_0000_for_unix :: () -> Apollo_Time {
    c0000: Calendar_Time;
    c0000.time_zone = .UTC;

    a0000 := calendar_to_apollo(c0000);
    context.print_style.default_format_int.base = 16;
    context.print_style.default_format_int.digits_per_comma = 4;
    context.print_style.default_format_int.comma_string = "_";
    print("a0000: %\n", a0000);

    return a0000;
}
